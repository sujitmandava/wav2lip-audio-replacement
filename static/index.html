<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lip Sync API - Demo Interface</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 40px;
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 24px;
            font-size: 1.1em;
        }

        .upload-section {
            margin-bottom: 30px;
            padding: 25px;
            border: 2px dashed #ddd;
            border-radius: 15px;
            transition: border-color 0.3s ease;
        }

        .upload-section:hover {
            border-color: #667eea;
        }

        .upload-section h3 {
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .upload-section h3::before {
            content: "üìÅ";
            margin-right: 10px;
            font-size: 1.2em;
        }

        .file-input {
            width: 100%;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 10px;
            transition: border-color 0.3s ease;
        }

        .file-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .paragraph-text {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            font-style: italic;
            color: #555;
            font-size: 14px;
            line-height: 1.5;
        }

        .process-btn {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            margin-top: 30px;
        }

        .process-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .process-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .status-section {
            margin-top: 30px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
            display: none;
        }

        .status-section.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #e0e0e0;
            border-radius: 6px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 6px;
        }

        .status-message {
            font-weight: 500;
            color: #333;
            margin-bottom: 10px;
        }

        .download-btn {
            background: #28a745;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            text-decoration: none;
            display: inline-block;
            margin-top: 15px;
            font-weight: 500;
            transition: background-color 0.3s ease;
        }

        .download-btn:hover {
            background: #218838;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid #f5c6cb;
        }

        .api-info {
            background: #e8f4fd;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
            border-left: 4px solid #667eea;
        }

        .api-info h4 {
            color: #0066cc;
            margin-bottom: 10px;
        }

        .api-info p {
            color: #555;
            line-height: 1.5;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        .realtime-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .realtime-actions .process-btn {
            margin-top: 0;
            font-size: 16px;
            padding: 14px;
        }

        .toggle-btn {
            margin-top: 0;
            width: auto;
            min-width: 170px;
            padding: 10px 14px;
            font-size: 14px;
            border-radius: 8px;
            background: linear-gradient(135deg, #343a40 0%, #495057 100%);
        }

        .toggle-btn.on {
            background: linear-gradient(135deg, #198754 0%, #146c43 100%);
        }

        .stop-btn {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .realtime-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .realtime-number {
            width: 120px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 15px;
        }

        .realtime-text {
            width: 100%;
            min-height: 80px;
            resize: vertical;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.4;
        }

        .realtime-checkbox {
            display: flex;
            gap: 8px;
            align-items: center;
            font-size: 14px;
            color: #333;
        }

        .small-note {
            color: #555;
            font-size: 13px;
            margin-top: 8px;
        }

        .realtime-frame {
            width: 100%;
            margin-top: 14px;
            border: 1px solid #ddd;
            border-radius: 10px;
            min-height: 180px;
            max-height: 420px;
            object-fit: contain;
            background: #10161f;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
                margin: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .realtime-actions {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé≠ Lip Sync API</h1>
        <p class="subtitle">Audio Replacement with Lip Synchronization</p>

        <div class="api-info">
            <h4>üìã Assignment Instructions</h4>
            <p><strong>Input Video:</strong> Record yourself speaking Paragraph A clearly (10-15 seconds)<br>
            <strong>New Audio:</strong> Record yourself speaking Paragraph B clearly<br>
            <strong>Output:</strong> Video with your lip movements synced to Paragraph B audio</p>
        </div>

        <div class="upload-section">
            <h3>Input Video (Paragraph A)</h3>
            <input type="file" id="videoFile" class="file-input" accept="video/*" required>
            <div class="paragraph-text">
                <strong>Paragraph A:</strong> "Today, I'm going to show you how machine learning can transform everyday tasks. Whether it's identifying objects in images or generating text from scratch, the possibilities are truly endless. Let's dive into some amazing examples together."
            </div>
        </div>

        <div class="upload-section">
            <h3>New Audio (Paragraph B)</h3>
            <input type="file" id="audioFile" class="file-input" accept="audio/*" required>
            <div class="paragraph-text">
                <strong>Paragraph B:</strong> "The quick brown fox jumps over the lazy dog while a curious cat watches from the rooftop. Suddenly, a loud bark sends the animals running in every direction - pure chaos ensues."
            </div>
        </div>

        <button id="processBtn" class="process-btn" onclick="startProcessing()">
            üöÄ Start Lip Sync Processing
        </button>

        <div id="statusSection" class="status-section">
            <div id="statusMessage" class="status-message">Processing...</div>
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill"></div>
            </div>
            <div id="progressText">0%</div>
            <div id="errorMessage" class="error-message" style="display: none;"></div>
            <a id="downloadBtn" class="download-btn" style="display: none;">üì• Download Result</a>
        </div>

        <div class="upload-section">
            <h3>Realtime (Static Avatar + TTS)</h3>
            <input type="file" id="realtimeAvatarFile" class="file-input" accept="image/*">
            <div class="realtime-row">
                <label for="realtimeFps">FPS</label>
                <input id="realtimeFps" class="realtime-number" type="number" min="5" max="30" step="1" value="15">
            </div>
            <div class="realtime-row">
                <label class="realtime-checkbox" for="realtimePlayAudio">
                    <input id="realtimePlayAudio" type="checkbox" checked>
                    Play audio
                </label>
                <label class="realtime-checkbox" for="realtimeAutoSync">
                    <input id="realtimeAutoSync" type="checkbox" checked>
                    Auto sync
                </label>
                <label for="realtimeAudioDelayMs">Delay (ms)</label>
                <input id="realtimeAudioDelayMs" class="realtime-number" type="number" min="0" max="1500" step="10" value="250">
                <button id="realtimeAutoSyncToggle" class="process-btn toggle-btn on" type="button" onclick="toggleAutoSync()">Auto Sync: ON</button>
            </div>
            <div class="realtime-row">
                <label class="realtime-checkbox" for="realtimeCpuAutoMode">
                    <input id="realtimeCpuAutoMode" type="checkbox" checked>
                    CPU Auto-Sync Mode
                </label>
                <span class="small-note">Preset: FPS 7, Delay 600ms, Rate 125, Head motion off during drift tuning.</span>
            </div>
            <div class="realtime-row">
                <label class="realtime-checkbox" for="realtimeHeadMotion">
                    <input id="realtimeHeadMotion" type="checkbox" checked>
                    Head motion
                </label>
                <label for="realtimeHeadMotionStrength">Motion</label>
                <input id="realtimeHeadMotionStrength" class="realtime-number" type="number" min="0" max="1.5" step="0.05" value="0.55">
            </div>
            <textarea id="realtimeTtsText" class="realtime-text" placeholder="Type text for avatar speech..."></textarea>
            <div class="realtime-row">
                <label for="realtimeTtsVoice">Voice</label>
                <input id="realtimeTtsVoice" class="realtime-number" style="width: 180px;" type="text" placeholder="default">
                <label for="realtimeTtsRate">Rate</label>
                <input id="realtimeTtsRate" class="realtime-number" type="number" min="80" max="320" step="5" value="105">
            </div>
            <div class="small-note">Upload one face image, start realtime, then use TTS text as the speech input. Auto-sync keeps user speech rate fixed and matches frame pacing/delay.</div>
            <div id="realtimeStatus" class="status-message" style="margin-top: 12px;">Realtime idle.</div>
            <div class="realtime-actions">
                <button id="startRealtimeBtn" class="process-btn" onclick="startRealtime()">‚ñ∂Ô∏è Start Realtime</button>
                <button id="stopRealtimeBtn" class="process-btn stop-btn" onclick="stopRealtime()" disabled>‚èπÔ∏è Stop Realtime</button>
            </div>
            <div class="realtime-actions">
                <button id="speakTextBtn" class="process-btn" onclick="speakTextToAvatar()" disabled>üó£Ô∏è Speak Text (TTS)</button>
            </div>
            <img id="realtimeFrame" class="realtime-frame" alt="Realtime generated frame stream">
        </div>
    </div>

    <script>
        let currentJobId = null;
        let statusCheckInterval = null;
        const API_BASE = window.location.origin;

        let realtimeSessionId = null;
        let realtimeSocket = null;
        let realtimeAudioContext = null;
        let realtimeLastFrameUrl = null;
        let realtimeTtsStreaming = false;
        let realtimeFramesReceived = 0;
        let realtimeFrameTimestamps = [];
        let realtimeRequestedFps = 15;
        let realtimeCpuPresetApplied = false;
        let realtimeLastAdaptiveFpsChangeAt = 0;
        let realtimeIdleLoopTask = null;
        let realtimeIdleLoopToken = 0;

        async function startProcessing() {
            const videoFile = document.getElementById('videoFile').files[0];
            const audioFile = document.getElementById('audioFile').files[0];

            if (!videoFile || !audioFile) {
                alert('Please select both video and audio files');
                return;
            }

            const formData = new FormData();
            formData.append('input_video', videoFile);
            formData.append('new_audio', audioFile);

            document.getElementById('processBtn').disabled = true;
            document.getElementById('processBtn').innerHTML = '‚è≥ Starting Processing... <div class="loading"></div>';
            document.getElementById('statusSection').classList.add('show');
            document.getElementById('statusMessage').textContent = 'Uploading files...';

            try {
                const response = await fetch(`${API_BASE}/process`, {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (response.ok) {
                    currentJobId = result.job_id;
                    document.getElementById('statusMessage').textContent = result.message;
                    statusCheckInterval = setInterval(checkStatus, 2000);
                } else {
                    throw new Error(result.detail || 'Processing failed');
                }

            } catch (error) {
                showError(`Error starting processing: ${error.message}`);
                resetUI();
            }
        }

        async function checkStatus() {
            if (!currentJobId) return;

            try {
                const response = await fetch(`${API_BASE}/status/${currentJobId}`);
                const status = await response.json();

                document.getElementById('statusMessage').textContent = status.message;

                if (status.progress !== undefined) {
                    document.getElementById('progressFill').style.width = `${status.progress}%`;
                    document.getElementById('progressText').textContent = `${Math.round(status.progress)}%`;
                }

                if (status.status === 'completed') {
                    clearInterval(statusCheckInterval);
                    document.getElementById('statusMessage').textContent = '‚úÖ Processing completed successfully!';
                    document.getElementById('downloadBtn').style.display = 'inline-block';
                    document.getElementById('downloadBtn').href = `${API_BASE}/download/${currentJobId}`;
                    resetUI();
                } else if (status.status === 'failed') {
                    clearInterval(statusCheckInterval);
                    showError(`Processing failed: ${status.error}`);
                    resetUI();
                }

            } catch (error) {
                console.error('Error checking status:', error);
                clearInterval(statusCheckInterval);
                showError('Error checking processing status');
                resetUI();
            }
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function resetUI() {
            document.getElementById('processBtn').disabled = false;
            document.getElementById('processBtn').innerHTML = 'üöÄ Start Lip Sync Processing';
        }

        function setRealtimeStatus(message) {
            document.getElementById('realtimeStatus').textContent = message;
        }

        function setRealtimeButtons(active) {
            document.getElementById('startRealtimeBtn').disabled = active;
            document.getElementById('stopRealtimeBtn').disabled = !active;
            document.getElementById('speakTextBtn').disabled = !active;
        }

        function isRealtimeSocketOpen() {
            return !!realtimeSocket && realtimeSocket.readyState === WebSocket.OPEN;
        }

        function sleepMs(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function stopRealtimeIdleLoop() {
            realtimeIdleLoopToken += 1;
            realtimeIdleLoopTask = null;
        }

        function startRealtimeIdleLoop() {
            if (!isRealtimeSocketOpen()) {
                return null;
            }

            if (realtimeIdleLoopTask) {
                return realtimeIdleLoopTask;
            }

            const token = ++realtimeIdleLoopToken;
            const chunkMs = 40;
            const chunkSamples = Math.max(1, Math.floor((16000 * chunkMs) / 1000));
            const silentChunk = new Float32Array(chunkSamples);

            realtimeIdleLoopTask = (async () => {
                while (token === realtimeIdleLoopToken) {
                    if (!isRealtimeSocketOpen()) {
                        break;
                    }

                    if (!realtimeTtsStreaming) {
                        try {
                            realtimeSocket.send(silentChunk);
                        } catch (error) {
                            console.error('Realtime idle stream send failed:', error);
                            break;
                        }
                    }

                    await sleepMs(chunkMs);
                }
            })().finally(() => {
                if (token === realtimeIdleLoopToken) {
                    realtimeIdleLoopTask = null;
                }
            });

            return realtimeIdleLoopTask;
        }

        function isCpuAutoSyncModeEnabled() {
            const autoSync = document.getElementById('realtimeAutoSync').checked;
            const cpuMode = document.getElementById('realtimeCpuAutoMode').checked;
            return autoSync && cpuMode;
        }

        function updateAutoSyncUi() {
            const autoSync = document.getElementById('realtimeAutoSync').checked;
            const btn = document.getElementById('realtimeAutoSyncToggle');
            if (!btn) {
                return;
            }
            btn.textContent = `Auto Sync: ${autoSync ? 'ON' : 'OFF'}`;
            btn.classList.toggle('on', autoSync);
        }

        function toggleAutoSync() {
            const checkbox = document.getElementById('realtimeAutoSync');
            checkbox.checked = !checkbox.checked;
            updateAutoSyncUi();
            if (isCpuAutoSyncModeEnabled()) {
                realtimeCpuPresetApplied = false;
                applyCpuAutoSyncPreset(true);
            }
        }

        function applyCpuAutoSyncPreset(force = false) {
            if (!document.getElementById('realtimeCpuAutoMode').checked) {
                return;
            }

            const fpsInput = document.getElementById('realtimeFps');
            const delayInput = document.getElementById('realtimeAudioDelayMs');
            const rateInput = document.getElementById('realtimeTtsRate');
            const headMotionInput = document.getElementById('realtimeHeadMotion');
            const headMotionStrengthInput = document.getElementById('realtimeHeadMotionStrength');

            let fps = Number(fpsInput.value || 7);
            if (fps < 6 || fps > 8) {
                fps = 7;
                fpsInput.value = String(fps);
            }

            if (force || !realtimeCpuPresetApplied) {
                delayInput.value = "600";
                let rate = Number(rateInput.value || 125);
                if (rate < 120 || rate > 140) {
                    rate = 125;
                }
                rateInput.value = String(rate);
                headMotionInput.checked = false;
                headMotionStrengthInput.value = "0.25";
                realtimeCpuPresetApplied = true;
            }
        }

        function sendRealtimeConfigUpdate() {
            if (!realtimeSocket || realtimeSocket.readyState !== WebSocket.OPEN) {
                return;
            }
            const headMotion = document.getElementById('realtimeHeadMotion').checked;
            const headMotionStrength = Number(document.getElementById('realtimeHeadMotionStrength').value || 0.55);
            const fps = Number(document.getElementById('realtimeFps').value || realtimeRequestedFps || 7);
            realtimeSocket.send(JSON.stringify({
                type: 'config',
                input_sample_rate: 16000,
                fps: fps,
                head_motion: headMotion,
                head_motion_strength: headMotionStrength,
            }));
        }

        async function createRealtimeSession(avatarFile, fps, inputSampleRate, headMotion, headMotionStrength) {
            const form = new FormData();
            form.append('avatar_image', avatarFile);
            form.append('fps', String(fps));
            form.append('input_sample_rate', String(inputSampleRate));
            form.append('head_motion', String(Boolean(headMotion)));
            form.append('head_motion_strength', String(Number(headMotionStrength)));

            const response = await fetch(`${API_BASE}/realtime/session`, {
                method: 'POST',
                body: form,
            });
            const payload = await response.json();
            if (!response.ok) {
                throw new Error(payload.detail || 'Failed to create realtime session');
            }
            return payload;
        }

        function cleanupRealtimeAudioGraph() {
            if (realtimeAudioContext) {
                realtimeAudioContext.close().catch(() => {});
                realtimeAudioContext = null;
            }
        }

        function estimateRealtimeGeneratedFps() {
            if (realtimeFrameTimestamps.length < 2) {
                return 0;
            }
            const first = realtimeFrameTimestamps[0];
            const last = realtimeFrameTimestamps[realtimeFrameTimestamps.length - 1];
            const dt = last - first;
            if (dt <= 0) {
                return 0;
            }
            return ((realtimeFrameTimestamps.length - 1) * 1000.0) / dt;
        }

        async function waitForFrameGeneration(frameCountAtStart, timeoutMs = 4000) {
            const start = Date.now();
            while (Date.now() - start < timeoutMs) {
                if (realtimeFramesReceived > frameCountAtStart) {
                    return true;
                }
                if (!realtimeSocket || realtimeSocket.readyState !== WebSocket.OPEN) {
                    return false;
                }
                await new Promise(resolve => setTimeout(resolve, 25));
            }
            return false;
        }

        async function fetchTtsAudioBlob(text, voice, rate) {
            const form = new FormData();
            form.append('text', text);
            form.append('voice', voice || '');
            form.append('rate', String(rate));

            const response = await fetch(`${API_BASE}/realtime/tts`, {
                method: 'POST',
                body: form,
            });

            if (!response.ok) {
                let detail = 'TTS request failed';
                try {
                    const payload = await response.json();
                    detail = payload.detail || detail;
                } catch (error) {
                    console.error('Could not parse TTS error response:', error);
                }
                throw new Error(detail);
            }

            return await response.blob();
        }

        function audioBufferToMonoF32(decoded) {
            const channels = decoded.numberOfChannels || 1;
            const length = decoded.length || 0;
            if (length <= 0) {
                return new Float32Array(0);
            }

            if (channels === 1) {
                return new Float32Array(decoded.getChannelData(0));
            }

            const out = new Float32Array(length);
            for (let c = 0; c < channels; c += 1) {
                const data = decoded.getChannelData(c);
                for (let i = 0; i < length; i += 1) {
                    out[i] += data[i];
                }
            }
            const inv = 1.0 / channels;
            for (let i = 0; i < length; i += 1) {
                out[i] *= inv;
            }
            return out;
        }

        function resampleLinearMonoTo16k(input, inputSampleRate) {
            if (!input || input.length === 0) {
                return new Float32Array(0);
            }
            const srcSr = Number(inputSampleRate || 0);
            if (!Number.isFinite(srcSr) || srcSr <= 0) {
                throw new Error(`Invalid source sample rate: ${inputSampleRate}`);
            }
            if (Math.abs(srcSr - 16000) < 1e-3) {
                return new Float32Array(input);
            }

            const outLength = Math.max(1, Math.round((input.length * 16000) / srcSr));
            const out = new Float32Array(outLength);
            const scale = (input.length - 1) / Math.max(1, outLength - 1);
            for (let i = 0; i < outLength; i += 1) {
                const pos = i * scale;
                const i0 = Math.floor(pos);
                const i1 = Math.min(i0 + 1, input.length - 1);
                const frac = pos - i0;
                out[i] = (input[i0] * (1.0 - frac)) + (input[i1] * frac);
            }
            return out;
        }

        function decodeTo16kMono(decodedAudioBuffer) {
            const mono = audioBufferToMonoF32(decodedAudioBuffer);
            return resampleLinearMonoTo16k(mono, decodedAudioBuffer.sampleRate);
        }

        function playAudioBlobWithDelay(audioBuffer, delaySec = 0) {
            if (!realtimeAudioContext) {
                return;
            }
            const gain = realtimeAudioContext.createGain();
            gain.gain.value = 1.0;
            const source = realtimeAudioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(gain);
            gain.connect(realtimeAudioContext.destination);
            source.start(realtimeAudioContext.currentTime + delaySec);
        }

        async function streamPcm16kToRealtimeSocket(pcm16k, options = {}) {
            const chunkMs = Number(options.chunkMs || 40);
            const chunkSamples = Math.max(1, Math.floor((16000 * chunkMs) / 1000));
            const pace = options.pace !== false;
            const autoSync = options.autoSync === true;
            let fpsTarget = Number(options.fpsTarget || realtimeRequestedFps || 15);
            const frameCountAtStart = Number(options.frameCountAtStart || realtimeFramesReceived);
            const adaptiveSync = options.adaptiveSync === true;
            const onAdaptiveEvent = typeof options.onAdaptiveEvent === 'function' ? options.onAdaptiveEvent : null;
            let sentSamples = 0;
            const startedAt = performance.now();
            let driftSumSec = 0.0;
            let driftCount = 0;
            let driftMaxSec = 0.0;
            let lastAdaptiveCheckAt = 0.0;

            while (sentSamples < pcm16k.length) {
                if (!realtimeSocket || realtimeSocket.readyState !== WebSocket.OPEN) {
                    throw new Error('Realtime socket closed while streaming TTS audio');
                }

                if (pace) {
                    const elapsedSec = Math.max(0.0, (performance.now() - startedAt) / 1000.0);
                    // Keep audio pacing tied to real time, not generated-frame count.
                    // This prevents autosync from making long utterances feel accelerated.
                    const leadSec = autoSync ? 0.35 : 0.12;
                    const maxAudioSec = elapsedSec + leadSec;
                    const sentSec = sentSamples / 16000.0;
                    if (sentSec > maxAudioSec) {
                        const waitMs = Math.min(50, Math.max(2, Math.round((sentSec - maxAudioSec) * 1000)));
                        await new Promise(resolve => setTimeout(resolve, waitMs));
                        continue;
                    }
                }

                if (adaptiveSync) {
                    const nowMs = performance.now();
                    if ((nowMs - lastAdaptiveCheckAt) >= 250.0) {
                        lastAdaptiveCheckAt = nowMs;
                        const fpsNow = Math.max(1.0, Number(estimateRealtimeGeneratedFps() || fpsTarget || 7));
                        const producedFrames = Math.max(0, realtimeFramesReceived - frameCountAtStart);
                        const producedSec = producedFrames / fpsNow;
                        const sentSec = sentSamples / 16000.0;
                        const driftSec = Math.max(0.0, sentSec - producedSec);

                        driftSumSec += driftSec;
                        driftCount += 1;
                        driftMaxSec = Math.max(driftMaxSec, driftSec);

                        const delayInput = document.getElementById('realtimeAudioDelayMs');
                        const currentDelayMs = Number(delayInput.value || 600);
                        const suggestedDelayMs = Math.max(300, Math.min(1300, Math.round(600 + (driftSec * 550))));
                        const nextDelayMs = Math.round((currentDelayMs * 0.82) + (suggestedDelayMs * 0.18));
                        delayInput.value = String(nextDelayMs);

                        if (driftSec > 0.90 && fpsTarget > 6 && (nowMs - realtimeLastAdaptiveFpsChangeAt) > 1800.0) {
                            fpsTarget = Math.max(6, fpsTarget - 1);
                            realtimeRequestedFps = fpsTarget;
                            realtimeLastAdaptiveFpsChangeAt = nowMs;
                            document.getElementById('realtimeFps').value = String(fpsTarget);
                            sendRealtimeConfigUpdate();
                            if (onAdaptiveEvent) {
                                onAdaptiveEvent({ type: 'fps_drop', fps: fpsTarget, driftSec });
                            }
                        }
                    }
                }

                const end = Math.min(sentSamples + chunkSamples, pcm16k.length);
                const chunk = pcm16k.subarray(sentSamples, end);
                const chunkBytes = chunk.buffer.slice(chunk.byteOffset, chunk.byteOffset + chunk.byteLength);
                realtimeSocket.send(chunkBytes);
                sentSamples = end;
            }

            return {
                avgDriftSec: driftCount > 0 ? (driftSumSec / driftCount) : 0.0,
                maxDriftSec: driftMaxSec,
                finalFpsTarget: fpsTarget,
            };
        }

        async function speakTextToAvatar() {
            if (!realtimeSocket || realtimeSocket.readyState !== WebSocket.OPEN) {
                alert('Start realtime first, then use TTS.');
                return;
            }
            if (!realtimeAudioContext) {
                alert('Realtime audio context is not initialized.');
                return;
            }
            if (realtimeTtsStreaming) {
                return;
            }

            const text = (document.getElementById('realtimeTtsText').value || '').trim();
            const voice = document.getElementById('realtimeTtsVoice').value || '';
            const rate = Number(document.getElementById('realtimeTtsRate').value || 125);
            const playAudio = document.getElementById('realtimePlayAudio').checked;
            const autoSync = document.getElementById('realtimeAutoSync').checked;
            const cpuAutoMode = isCpuAutoSyncModeEnabled();
            const audioDelayMs = Number(document.getElementById('realtimeAudioDelayMs').value || 0);

            if (!text) {
                alert('Enter text for TTS.');
                return;
            }
            if (rate < 80 || rate > 320) {
                alert('TTS rate must be between 80 and 320.');
                return;
            }

            document.getElementById('speakTextBtn').disabled = true;
            realtimeTtsStreaming = true;
            setRealtimeStatus('Generating TTS audio...');

            try {
                if (cpuAutoMode) {
                    applyCpuAutoSyncPreset(false);
                }
                // Keep speech speed fixed to exactly what user configured.
                const requestedRate = Math.max(80, Math.min(320, Math.round(rate)));
                const wavBlob = await fetchTtsAudioBlob(text, voice, requestedRate);
                const wavArrayBuffer = await wavBlob.arrayBuffer();
                const decoded = await realtimeAudioContext.decodeAudioData(wavArrayBuffer.slice(0));

                const pcm16k = decodeTo16kMono(decoded);
                if (!pcm16k || pcm16k.length === 0) {
                    throw new Error('Could not convert TTS audio to 16 kHz.');
                }
                const playbackBuffer = realtimeAudioContext.createBuffer(1, pcm16k.length, 16000);
                playbackBuffer.getChannelData(0).set(pcm16k);

                const frameStart = realtimeFramesReceived;
                setRealtimeStatus(autoSync ? 'Streaming TTS with auto-sync...' : 'Streaming TTS audio to avatar...');

                const streamPromise = streamPcm16kToRealtimeSocket(pcm16k, {
                    chunkMs: 40,
                    pace: true,
                    autoSync,
                    adaptiveSync: cpuAutoMode,
                    fpsTarget: realtimeRequestedFps,
                    frameCountAtStart: frameStart,
                    onAdaptiveEvent: (evt) => {
                        if (evt && evt.type === 'fps_drop') {
                            setRealtimeStatus(`Auto-sync tuned FPS to ${evt.fps} due to drift (${evt.driftSec.toFixed(2)}s).`);
                        }
                    },
                });

                let usedDelay = audioDelayMs;
                if (cpuAutoMode) {
                    usedDelay = Math.max(600, usedDelay);
                }
                if (playAudio) {
                    if (autoSync && !cpuAutoMode) {
                        const hadFrame = await waitForFrameGeneration(frameStart, 4000);
                        if (hadFrame) {
                            const fpsNow = Number(estimateRealtimeGeneratedFps() || realtimeRequestedFps || 8);
                            usedDelay = Math.max(120, Math.min(900, Math.round((1000 / Math.max(1, fpsNow)) * 1.4)));
                        }
                    }
                    if (cpuAutoMode) {
                        usedDelay = Number(document.getElementById('realtimeAudioDelayMs').value || usedDelay || 600);
                    }
                    playAudioBlobWithDelay(playbackBuffer, usedDelay / 1000.0);
                }

                const streamSummary = await streamPromise;

                const genFps = estimateRealtimeGeneratedFps();
                if (autoSync) {
                    const fpsText = genFps ? genFps.toFixed(1) : String(realtimeRequestedFps);
                    const driftText = streamSummary ? streamSummary.avgDriftSec.toFixed(2) : "0.00";
                    setRealtimeStatus(`TTS synced. gen_fps=${fpsText}, delay=${Math.round(usedDelay)}ms, rate=${requestedRate}, drift=${driftText}s. Avatar returned to idle.`);
                } else {
                    setRealtimeStatus('TTS streaming complete. Avatar returned to idle.');
                }

                if (cpuAutoMode && streamSummary && streamSummary.avgDriftSec <= 0.35) {
                    const headMotionToggle = document.getElementById('realtimeHeadMotion');
                    const headMotionStrengthInput = document.getElementById('realtimeHeadMotionStrength');
                    if (!headMotionToggle.checked) {
                        headMotionToggle.checked = true;
                        headMotionStrengthInput.value = "0.25";
                        sendRealtimeConfigUpdate();
                        setRealtimeStatus(`CPU auto-sync stable. Re-enabled head motion at 0.25.`);
                    }
                }
            } catch (error) {
                setRealtimeStatus(`TTS failed: ${error.message}`);
            } finally {
                realtimeTtsStreaming = false;
                if (isRealtimeSocketOpen()) {
                    document.getElementById('speakTextBtn').disabled = false;
                    startRealtimeIdleLoop();
                }
            }
        }

        async function startRealtime() {
            applyCpuAutoSyncPreset(false);
            const avatarFile = document.getElementById('realtimeAvatarFile').files[0];
            const fps = Number(document.getElementById('realtimeFps').value || 15);
            const headMotion = document.getElementById('realtimeHeadMotion').checked;
            const headMotionStrength = Number(document.getElementById('realtimeHeadMotionStrength').value || 0.55);

            if (!avatarFile) {
                alert('Please select an avatar image for realtime mode.');
                return;
            }
            if (fps < 5 || fps > 30) {
                alert('Realtime FPS must be between 5 and 30.');
                return;
            }
            if (headMotionStrength < 0 || headMotionStrength > 1.5) {
                alert('Head motion strength must be between 0.0 and 1.5.');
                return;
            }
            if (realtimeSocket) {
                alert('Realtime session is already running.');
                return;
            }

            stopRealtimeIdleLoop();
            realtimeAudioContext = new (window.AudioContext || window.webkitAudioContext)();
            realtimeRequestedFps = fps;
            realtimeFramesReceived = 0;
            realtimeFrameTimestamps = [];

            setRealtimeStatus('Creating realtime session...');
            try {
                const session = await createRealtimeSession(
                    avatarFile,
                    fps,
                    16000,
                    headMotion,
                    headMotionStrength
                );

                realtimeSessionId = session.session_id;

                realtimeSocket = new WebSocket(session.ws_url);
                realtimeSocket.binaryType = 'blob';

                realtimeSocket.onopen = () => {
                    setRealtimeButtons(true);
                    startRealtimeIdleLoop();
                    setRealtimeStatus(`Realtime running at ${fps} FPS (idle active).`);
                };

                realtimeSocket.onmessage = (event) => {
                    if (typeof event.data === 'string') {
                        try {
                            const msg = JSON.parse(event.data);
                            if (msg.type === 'error') {
                                setRealtimeStatus(`Realtime error: ${msg.message}`);
                            }
                        } catch {
                            setRealtimeStatus('Received invalid control message from server.');
                        }
                        return;
                    }

                    if (realtimeLastFrameUrl) {
                        URL.revokeObjectURL(realtimeLastFrameUrl);
                    }
                    realtimeLastFrameUrl = URL.createObjectURL(event.data);
                    document.getElementById('realtimeFrame').src = realtimeLastFrameUrl;

                    const now = performance.now();
                    realtimeFramesReceived += 1;
                    realtimeFrameTimestamps.push(now);
                    while (realtimeFrameTimestamps.length > 0 && (now - realtimeFrameTimestamps[0]) > 5000) {
                        realtimeFrameTimestamps.shift();
                    }
                };

                realtimeSocket.onerror = () => {
                    setRealtimeStatus('Realtime websocket error.');
                };

                realtimeSocket.onclose = () => {
                    stopRealtimeIdleLoop();
                    setRealtimeStatus('Realtime stopped.');
                    setRealtimeButtons(false);
                    cleanupRealtimeAudioGraph();
                    realtimeTtsStreaming = false;
                    realtimeSocket = null;
                    realtimeSessionId = null;
                };
            } catch (error) {
                stopRealtimeIdleLoop();
                setRealtimeStatus(`Realtime start failed: ${error.message}`);
                setRealtimeButtons(false);
                cleanupRealtimeAudioGraph();
                realtimeSocket = null;
                realtimeSessionId = null;
            }
        }

        async function stopRealtime() {
            const sessionId = realtimeSessionId;
            stopRealtimeIdleLoop();

            if (realtimeSocket && realtimeSocket.readyState === WebSocket.OPEN) {
                try {
                    realtimeSocket.send(JSON.stringify({ type: 'close' }));
                } catch (_) {}
            }

            if (realtimeSocket) {
                realtimeSocket.close();
            }
            cleanupRealtimeAudioGraph();

            realtimeSocket = null;
            realtimeSessionId = null;
            realtimeTtsStreaming = false;
            setRealtimeButtons(false);
            setRealtimeStatus('Stopping realtime session...');

            if (sessionId) {
                try {
                    await fetch(`${API_BASE}/realtime/session/${sessionId}`, { method: 'DELETE' });
                } catch (error) {
                    console.error('Realtime session delete failed:', error);
                }
            }

            if (realtimeLastFrameUrl) {
                URL.revokeObjectURL(realtimeLastFrameUrl);
                realtimeLastFrameUrl = null;
            }
        }

        document.getElementById('videoFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const validTypes = ['video/mp4', 'video/avi', 'video/mov', 'video/mkv'];
                if (!validTypes.includes(file.type)) {
                    alert('Please select a valid video file (MP4, AVI, MOV, MKV)');
                    e.target.value = '';
                    return;
                }

                if (file.size > 100 * 1024 * 1024) {
                    alert('Video file too large. Please select a file smaller than 100MB');
                    e.target.value = '';
                    return;
                }
            }
        });

        document.getElementById('audioFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const validTypes = ['audio/wav', 'audio/mp3', 'audio/mpeg', 'audio/m4a', 'audio/flac'];
                if (!validTypes.includes(file.type)) {
                    alert('Please select a valid audio file (WAV, MP3, M4A, FLAC)');
                    e.target.value = '';
                    return;
                }

                if (file.size > 50 * 1024 * 1024) {
                    alert('Audio file too large. Please select a file smaller than 50MB');
                    e.target.value = '';
                    return;
                }
            }
        });

        document.getElementById('realtimeHeadMotion').addEventListener('change', function() {
            sendRealtimeConfigUpdate();
        });
        document.getElementById('realtimeHeadMotionStrength').addEventListener('change', function() {
            sendRealtimeConfigUpdate();
        });
        document.getElementById('realtimeFps').addEventListener('change', function() {
            sendRealtimeConfigUpdate();
        });
        document.getElementById('realtimeAutoSync').addEventListener('change', function() {
            updateAutoSyncUi();
            if (isCpuAutoSyncModeEnabled()) {
                realtimeCpuPresetApplied = false;
                applyCpuAutoSyncPreset(true);
            }
        });
        document.getElementById('realtimeCpuAutoMode').addEventListener('change', function() {
            if (document.getElementById('realtimeCpuAutoMode').checked) {
                realtimeCpuPresetApplied = false;
                applyCpuAutoSyncPreset(true);
                setRealtimeStatus('CPU auto-sync mode enabled. Applied preset: FPS 7, Delay 600ms, Rate 125, Head motion off.');
            } else {
                setRealtimeStatus('CPU auto-sync mode disabled.');
            }
        });
        applyCpuAutoSyncPreset(false);
        updateAutoSyncUi();
    </script>
</body>
</html>
